<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Biomarker Analyzer - Non-invasive Health Monitoring</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: white;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
            border: 1px solid rgba(255, 255, 255, 0.18);
        }

        h1 {
            text-align: center;
            margin-bottom: 10px;
            font-size: 2.5em;
            font-weight: 300;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .subtitle {
            text-align: center;
            margin-bottom: 30px;
            opacity: 0.9;
            font-size: 1.1em;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        button {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            border: none;
            color: white;
            padding: 15px 30px;
            border-radius: 50px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px 0 rgba(255, 107, 107, 0.3);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px 0 rgba(255, 107, 107, 0.4);
        }

        button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }

        select {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 12px 20px;
            border-radius: 25px;
            font-size: 16px;
            outline: none;
            backdrop-filter: blur(10px);
        }

        select option {
            background: #333;
            color: white;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        .video-section {
            position: relative;
        }

        #videoCanvas {
            width: 100%;
            height: auto;
            border-radius: 15px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        .metrics-panel {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 25px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .metric-card {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .metric-value {
            font-size: 2.5em;
            font-weight: bold;
            margin: 10px 0;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .metric-label {
            font-size: 1.1em;
            opacity: 0.9;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .status {
            text-align: center;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            font-weight: 600;
            font-size: 1.1em;
        }

        .status.ready {
            background: rgba(46, 204, 113, 0.3);
            border: 1px solid rgba(46, 204, 113, 0.5);
        }

        .status.monitoring {
            background: rgba(52, 152, 219, 0.3);
            border: 1px solid rgba(52, 152, 219, 0.5);
            animation: pulse 2s infinite;
        }

        .status.error {
            background: rgba(231, 76, 60, 0.3);
            border: 1px solid rgba(231, 76, 60, 0.5);
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }

        .instructions {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .instructions h3 {
            margin-bottom: 15px;
            color: #ffd700;
        }

        .instructions ul {
            list-style: none;
            padding-left: 0;
        }

        .instructions li {
            margin-bottom: 8px;
            padding-left: 20px;
            position: relative;
        }

        .instructions li:before {
            content: "â†’";
            position: absolute;
            left: 0;
            color: #ffd700;
            font-weight: bold;
        }

        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            
            .controls {
                flex-direction: column;
                align-items: center;
            }
            
            h1 {
                font-size: 2em;
            }
            
            .container {
                padding: 20px;
                margin: 10px;
            }
        }

        .data-export {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            text-align: center;
        }

        .tracking-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #e74c3c;
            border: 2px solid white;
            z-index: 10;
        }

        .tracking-indicator.active {
            background: #2ecc71;
            animation: pulse 1s infinite;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Biomarker Analyzer</h1>
        <p class="subtitle">Non-invasive Health Monitoring for Underserved Populations</p>
        
        <div class="instructions">
            <h3>Setup Instructions:</h3>
            <ul>
                <li><strong>Wear a WHITE shirt</strong> or place white paper on your chest</li>
                <li>Place a <strong>BLACK circle/dot</strong> (marker, sticker, coin) on the white area</li>
                <li>Ensure good lighting so black dot is clearly visible</li>
                <li><strong>Draw a rectangle around your chest area</strong> by dragging on the video</li>
                <li>The rectangle should cover where your breathing motion occurs</li>
                <li>Allow camera permissions when prompted</li>
            </ul>
        </div>

        <div class="controls">
            <button id="startBtn" onclick="toggleMonitoring()">Start Monitoring</button>
            <select id="frequencySelect" onchange="changeFrequency()">
                <option value="0.2">pgT (0.2 Hz) - Validated Signal</option>
                <option value="0.3">Respiratory (0.3 Hz)</option>
                <option value="1.0">Heart Rate (1.0 Hz)</option>
                <option value="1.5">Cardiac (1.5 Hz)</option>
                <option value="2.0">Micro-movements (2.0 Hz)</option>
            </select>
            <button onclick="exportData()">Export Data</button>
        </div>

        <div class="status" id="statusDisplay">Ready to start monitoring</div>

        <div class="main-content">
            <div class="video-section">
                <canvas id="videoCanvas" width="640" height="480"></canvas>
                <div class="tracking-indicator" id="trackingIndicator"></div>
            </div>
            
            <div class="metrics-panel">
                <div class="metric-card">
                    <div class="metric-label">Current Value</div>
                    <div class="metric-value" id="currentValue">0.00</div>
                </div>
                
                <div class="metric-card">
                    <div class="metric-label">Signal Quality</div>
                    <div class="metric-value" id="signalQuality">--</div>
                </div>
                
                <div class="metric-card">
                    <div class="metric-label">Tracking Status</div>
                    <div class="metric-value" id="trackingStatus">Waiting</div>
                </div>
                
                <div class="metric-card">
                    <div class="metric-label">Frequency</div>
                    <div class="metric-value" id="currentFreq">0.2 Hz</div>
                </div>
            </div>
        </div>

        <div class="data-export">
            <h3>Research Data Collection</h3>
            <p>Data points collected: <span id="dataCount">0</span></p>
            <p>Session duration: <span id="sessionTime">00:00</span></p>
        </div>
    </div>

    <script>
        class BiomarkerAnalyzer {
            constructor() {
                this.isMonitoring = false;
                this.stream = null;
                this.canvas = document.getElementById('videoCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.video = document.createElement('video');
                this.frequency = 0.2; // Default to pgT
                this.dataPoints = [];
                this.startTime = null;
                this.trackingQuality = 0;
                this.lastPixelCount = null;
                
                // ROI (Region of Interest) variables
                this.roi = null;
                this.isDrawingROI = false;
                this.roiStart = null;
                
                this.setupVideo();
                this.setupROIEvents();
                this.updateSessionTimer();
            }

            async setupVideo() {
                try {
                    this.video.playsInline = true;
                    this.video.muted = true;
                    this.video.onloadedmetadata = () => {
                        this.canvas.width = this.video.videoWidth;
                        this.canvas.height = this.video.videoHeight;
                    };
                } catch (error) {
                    console.error('Video setup error:', error);
                }
            }

            setupROIEvents() {
                // Mouse events for desktop
                this.canvas.addEventListener('mousedown', (e) => this.startROI(e));
                this.canvas.addEventListener('mousemove', (e) => this.updateROI(e));
                this.canvas.addEventListener('mouseup', (e) => this.finishROI(e));
                
                // Touch events for mobile
                this.canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.startROI(e.touches[0]);
                });
                this.canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    this.updateROI(e.touches[0]);
                });
                this.canvas.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.finishROI(e);
                });
            }

            getCanvasCoordinates(event) {
                const rect = this.canvas.getBoundingClientRect();
                const scaleX = this.canvas.width / rect.width;
                const scaleY = this.canvas.height / rect.height;
                
                return {
                    x: (event.clientX - rect.left) * scaleX,
                    y: (event.clientY - rect.top) * scaleY
                };
            }

            startROI(event) {
                if (this.isMonitoring) return; // Don't allow ROI changes during monitoring
                
                this.isDrawingROI = true;
                this.roiStart = this.getCanvasCoordinates(event);
                this.roi = null; // Clear existing ROI
            }

            updateROI(event) {
                if (!this.isDrawingROI) return;
                
                const current = this.getCanvasCoordinates(event);
                const width = current.x - this.roiStart.x;
                const height = current.y - this.roiStart.y;
                
                this.roi = {
                    x: Math.min(this.roiStart.x, current.x),
                    y: Math.min(this.roiStart.y, current.y),
                    width: Math.abs(width),
                    height: Math.abs(height)
                };
            }

            finishROI(event) {
                this.isDrawingROI = false;
                if (this.roi && (this.roi.width < 20 || this.roi.height < 20)) {
                    this.roi = null; // Remove tiny rectangles
                    this.updateStatus('ROI too small. Draw a larger rectangle.', 'error');
                } else if (this.roi) {
                    this.updateStatus('ROI selected. Click Start Monitoring to begin.', 'ready');
                }
            }

            async startCamera() {
                try {
                    const constraints = {
                        video: {
                            facingMode: 'user',
                            width: { ideal: 640, max: 1920 },
                            height: { ideal: 480, max: 1080 }
                        }
                    };

                    this.stream = await navigator.mediaDevices.getUserMedia(constraints);
                    this.video.srcObject = this.stream;
                    
                    await new Promise((resolve) => {
                        this.video.onloadedmetadata = resolve;
                    });
                    
                    await this.video.play();
                    return true;
                } catch (error) {
                    console.error('Camera access error:', error);
                    this.updateStatus('Camera access denied. Please allow camera permissions.', 'error');
                    return false;
                }
            }

            stopCamera() {
                if (this.stream) {
                    this.stream.getTracks().forEach(track => track.stop());
                    this.stream = null;
                }
            }

            async toggleMonitoring() {
                if (!this.isMonitoring) {
                    // Check if ROI is set
                    if (!this.roi) {
                        this.updateStatus('Please draw a rectangle on your chest area first!', 'error');
                        return;
                    }
                    
                    const cameraStarted = await this.startCamera();
                    if (!cameraStarted) return;
                    
                    this.isMonitoring = true;
                    this.startTime = Date.now();
                    this.dataPoints = [];
                    this.lastPixelCount = null;
                    document.getElementById('startBtn').textContent = 'Stop Monitoring';
                    this.updateStatus('Monitoring active - tracking black pixels in ROI', 'monitoring');
                    document.getElementById('trackingIndicator').classList.add('active');
                    this.monitoringLoop();
                } else {
                    this.isMonitoring = false;
                    this.stopCamera();
                    document.getElementById('startBtn').textContent = 'Start Monitoring';
                    this.updateStatus('Monitoring stopped. You can redraw ROI if needed.', 'ready');
                    document.getElementById('trackingIndicator').classList.remove('active');
                    // Keep the last frame visible
                }
            }

            monitoringLoop() {
                if (!this.isMonitoring) return;

                this.ctx.drawImage(this.video, 0, 0, this.canvas.width, this.canvas.height);
                
                // Detect white marker
                const whitePosition = this.detectWhiteMarker();
                
                if (whitePosition) {
                    this.processPhysiologicalSignal(whitePosition);
                    this.drawTrackingVisual(whitePosition);
                    document.getElementById('trackingStatus').textContent = 'Tracking';
                    this.trackingQuality = Math.min(this.trackingQuality + 0.1, 1.0);
                } else {
                    document.getElementById('trackingStatus').textContent = 'Searching';
                    this.trackingQuality = Math.max(this.trackingQuality - 0.05, 0);
                }

                this.updateSignalQuality();
                requestAnimationFrame(() => this.monitoringLoop());
            }

            detectWhiteMarker() {
                // If no ROI is set, return null
                if (!this.roi) {
                    return null;
                }

                const imageData = this.ctx.getImageData(this.roi.x, this.roi.y, this.roi.width, this.roi.height);
                const data = imageData.data;
                
                let blackPixelCount = 0;
                const threshold = 80; // Darkness threshold for black detection (lower = darker)
                
                // Count black pixels in the ROI
                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    
                    // Calculate darkness (inverse of brightness)
                    const brightness = (r + g + b) / 3;
                    const blackness = Math.max(r, g, b); // For black, all RGB should be low
                    
                    if (brightness < threshold && blackness < threshold + 30) {
                        blackPixelCount++;
                    }
                }
                
                // Return the pixel count as our signal
                return {
                    x: this.roi.x + this.roi.width / 2,
                    y: this.roi.y + this.roi.height / 2,
                    pixelCount: blackPixelCount,
                    totalPixels: (this.roi.width * this.roi.height)
                };
            }

            processPhysiologicalSignal(detectionResult) {
                const timestamp = Date.now();
                const relativeTime = (timestamp - this.startTime) / 1000; // seconds
                
                // Calculate pixel-based signal
                const pixelCount = detectionResult.pixelCount;
                const pixelRatio = pixelCount / detectionResult.totalPixels;
                
                // Calculate change in pixel count for signal
                let signal = 0;
                if (this.lastPixelCount !== null) {
                    signal = pixelCount - this.lastPixelCount;
                }
                this.lastPixelCount = pixelCount;
                
                // Apply frequency-specific processing
                const filteredSignal = this.applyFrequencyFilter(signal, relativeTime);
                
                // Store data point
                this.dataPoints.push({
                    timestamp: timestamp,
                    relativeTime: relativeTime,
                    rawSignal: signal,
                    filteredSignal: filteredSignal,
                    pixelCount: pixelCount,
                    pixelRatio: pixelRatio,
                    frequency: this.frequency,
                    roiArea: detectionResult.totalPixels
                });
                
                // Update display
                document.getElementById('currentValue').textContent = filteredSignal.toFixed(3);
                document.getElementById('dataCount').textContent = this.dataPoints.length;
            }

            applyFrequencyFilter(signal, time) {
                // Simple sinusoidal modulation based on target frequency
                // In a real implementation, you'd use proper digital filters
                const omega = 2 * Math.PI * this.frequency;
                const modulation = Math.sin(omega * time);
                return signal * (1 + 0.3 * modulation);
            }

            drawTrackingVisual(position) {
                // Draw tracking circle
                this.ctx.strokeStyle = '#2ecc71';
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                this.ctx.arc(position.x, position.y, 15, 0, 2 * Math.PI);
                this.ctx.stroke();
                
                // Draw center dot
                this.ctx.fillStyle = '#2ecc71';
                this.ctx.beginPath();
                this.ctx.arc(position.x, position.y, 3, 0, 2 * Math.PI);
                this.ctx.fill();
                
                // Draw crosshairs
                this.ctx.strokeStyle = '#2ecc71';
                this.ctx.lineWidth = 1;
                this.ctx.beginPath();
                this.ctx.moveTo(position.x - 10, position.y);
                this.ctx.lineTo(position.x + 10, position.y);
                this.ctx.moveTo(position.x, position.y - 10);
                this.ctx.lineTo(position.x, position.y + 10);
                this.ctx.stroke();
            }

            updateSignalQuality() {
                const quality = Math.round(this.trackingQuality * 100);
                document.getElementById('signalQuality').textContent = quality + '%';
            }

            updateStatus(message, type) {
                const statusEl = document.getElementById('statusDisplay');
                statusEl.textContent = message;
                statusEl.className = `status ${type}`;
            }

            changeFrequency() {
                this.frequency = parseFloat(document.getElementById('frequencySelect').value);
                document.getElementById('currentFreq').textContent = this.frequency + ' Hz';
            }

            exportData() {
                if (this.dataPoints.length === 0) {
                    alert('No data to export. Start monitoring first.');
                    return;
                }

                const csvContent = [
                    'Timestamp,RelativeTime(s),RawSignal,FilteredSignal,BlackPixelCount,BlackPixelRatio,Frequency(Hz),ROIArea',
                    ...this.dataPoints.map(point => 
                        `${point.timestamp},${point.relativeTime.toFixed(3)},${point.rawSignal.toFixed(6)},${point.filteredSignal.toFixed(6)},${point.pixelCount},${point.pixelRatio.toFixed(6)},${point.frequency},${point.roiArea}`
                    )
                ].join('\n');

                const blob = new Blob([csvContent], { type: 'text/csv' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `biomarker_black_pixel_data_${new Date().toISOString().slice(0,19).replace(/:/g,'-')}.csv`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);
            }

            updateSessionTimer() {
                if (this.startTime && this.isMonitoring) {
                    const elapsed = Math.floor((Date.now() - this.startTime) / 1000);
                    const minutes = Math.floor(elapsed / 60);
                    const seconds = elapsed % 60;
                    document.getElementById('sessionTime').textContent = 
                        `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                }
                setTimeout(() => this.updateSessionTimer(), 1000);
            }
        }

        // Initialize the application
        let analyzer;
        
        window.addEventListener('load', () => {
            analyzer = new BiomarkerAnalyzer();
        });

        // Global functions for HTML elements
        function toggleMonitoring() {
            analyzer.toggleMonitoring();
        }

        function changeFrequency() {
            analyzer.changeFrequency();
        }

        function exportData() {
            analyzer.exportData();
        }

        // Handle page visibility changes
        document.addEventListener('visibilitychange', () => {
            if (document.hidden && analyzer && analyzer.isMonitoring) {
                // Optionally pause monitoring when page is hidden
                console.log('Page hidden - monitoring continues');
            }
        });
    </script>
</body>
</html>
